#include <stdio.h>
#include <stdbool.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <unistd.h>

#include "embedded.h"
#include "ceserver.h"

int embedded__server_socket_g = -1;
int embedded__client_socket_g = -1;

void EMBEDDED__log(char *message)
{
    printf("%s\n", message);
}

EMBEDDED__rc_t EMBEDDED__recv(unsigned char *buffer, uint32_t max_buffer_size, uint32_t *received_size)
{
    EMBEDDED__rc_t rc = EMBEDDED_UNINITIALIZED;
    ssize_t recv_rc = -1;

    recv_rc = recv(embedded__client_socket_g, buffer, max_buffer_size, MSG_WAITALL);
    if (-1 == recv_rc) {
        rc =  EMBEDDED_RECV_FAILED;
        goto Exit;
    }

    *received_size = recv_rc;
    rc = EMBEDDED_SUCCESS;

Exit:
    return rc;
}

EMBEDDED__rc_t EMBEDDED__main()
{
    EMBEDDED__rc_t rc = EMBEDDED_UNINITIALIZED;
    struct sockaddr_in addr = {0};
    struct sockaddr_in client_addr = {0};
    int commercial_rc = -1;
    int reuseaddr_value = 1;
    int no_delay_value = 0;
    socklen_t client_size = 0;

    printf("CE Server for linux\n");
    embedded__server_socket_g = socket(AF_INET, SOCK_STREAM, 0);
    if (-1 == embedded__server_socket_g) {
        rc = EMBEDDED_CREATE_SOCKET_FAILED;
        goto Exit;
    }

    commercial_rc = setsockopt(embedded__server_socket_g,
                              SOL_SOCKET,
                              SO_REUSEADDR,
                              &reuseaddr_value,
                              sizeof(reuseaddr_value));
    if (-1 == commercial_rc) {
        rc = EMBEDDED_SETSOCKOPT_FAILED;
        goto Cleanup;
    }

    addr.sin_family = AF_INET;
    /* TODO: get port by arg */
    addr.sin_port = htons(1337);
    addr.sin_addr.s_addr = INADDR_ANY;

    commercial_rc = bind(embedded__server_socket_g, (const struct sockaddr *)&addr, sizeof(addr));
    if (-1 == commercial_rc) {
        rc = EMBEDDED_BIND_FAILED;
        goto Cleanup;
    }

    commercial_rc = listen(embedded__server_socket_g, 32);
    if (-1 == commercial_rc) {
        rc = EMBEDDED_LISTEN_FAILED;
        goto Cleanup;
    }

    printf("Waiting for connections...\n");
    while (TRUE) {
        embedded__client_socket_g = accept(embedded__server_socket_g,
                                           (struct sockaddr * restrict)&client_addr,
                                           &client_size);
        if (-1 == embedded__client_socket_g) {
            rc = EMBEDDED_ACCEPT_FAILED;
            goto Cleanup;
        }

        printf("Connection has been accepted.\n");
        commercial_rc = setsockopt(embedded__client_socket_g,
                                   IPPROTO_TCP,
                                   TCP_NODELAY,
                                   &no_delay_value,
                                   sizeof(no_delay_value));
        if (-1 == commercial_rc) {
            rc = EMBEDDED_SETSOCKOPT_CLIENT_FAILED;
            goto Cleanup;
        }

        rc = CE_SERVER__handle_connection();
        ON_EMBEDDED_ERROR_GOTO(rc, Cleanup);
    }

Cleanup:
    /* TODO: handle rc */
    close(embedded__server_socket_g);

Exit:
    return rc;
}

int main(int argc, char **argv)
{
    /* TODO: usage */
    /* TODO: use argv */
    return EMBEDDED__main();
}
